---
title: "Chapter Two Graphs"
author: "Alan Arnholt"
date: 'Last updated: `r format(Sys.time(), "%b %d, %Y")`'
output: html_document
---

```{r message = FALSE}
site <- "http://www-bcf.usc.edu/~gareth/ISL/Advertising.csv"
AD <- read.csv(site)
head(AD)
dim(AD)
library(DT)
datatable(AD[, -1], rownames = FALSE,
          caption = 'Table 1: This is a simple caption for the table.') 
```

## Base R Graph

```{r}
plot(Sales ~ TV, data = AD, col = "red", pch = 19)
mod1 <- lm(Sales ~ TV, data = AD)
abline(mod1, col = "blue")
```

## Using `ggplot2`

```{r}
library(ggplot2)
library(MASS)
p <- ggplot(data = AD, aes(x = TV, y = Sales)) +
  geom_point(color = "lightblue") +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  geom_smooth(method = "loess", color = "red", se = FALSE) + 
  geom_smooth(method = "rlm", color = "purple", se = FALSE) +
  theme_bw()
p
```

## Using `ggvis`

```{r message = FALSE}
library(ggvis)
AD %>% 
  ggvis(x = ~TV, y = ~Sales) %>% 
  layer_points() %>% 
  layer_model_predictions(model = "lm", se = FALSE) %>% 
  layer_model_predictions(model = "MASS::rlm", se = FALSE, stroke := "blue") %>%
  layer_smooths(stroke:="red", se = FALSE)
```

## Using `plotly`

```{r, message = FALSE}
library(plotly)
p2 <- ggplotly(p)
p2
```

## Scatterplot Matrices

```{r}
library(car)
scatterplotMatrix(~ Sales + TV + Radio + Newspaper, data = AD)
```


## Chapter 3

Recall `mod1`

```{r}
mod1 <- lm(Sales ~ TV, data = AD)
summary(mod1)
```

**Residual:** $e_i = y_i - \hat{y_i}$

To obtain the residuals for `mod1` use the function `resid` on a linear model object.

```{r}
eis <- resid(mod1)
RSS <- sum(eis^2)
RSS
RSE <- sqrt(RSS/(dim(AD)[1]-2))
RSE
# Or
summary(mod1)$sigma
```

The least squares estimators of $\beta_0$ and $\beta_1$ are

$$b_0 = \hat{\beta_0} = \bar{y} - b_1\bar{x}$$
$$b_1 = \hat{\beta_1} = \frac{\sum_{i = 1}^n(x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^n(x_i-\bar{x})^2}$$

```{r}
y <- AD$Sales
x <- AD$TV
b1 <- sum( (x - mean(x))*(y - mean(y)) ) / sum((x - mean(x))^2)
b0 <- mean(y) - b1*mean(x)
c(b0, b1)
# Or using
coef(mod1)
summary(mod1)
XTXI <- summary(mod1)$cov.unscaled
MSE <- summary(mod1)$sigma^2
var.cov.b <- MSE*XTXI
var.cov.b
seb0 <- sqrt(var.cov.b[1, 1])
seb1 <- sqrt(var.cov.b[2, 2])
c(seb0, seb1)
coef(summary(mod1))
coef(summary(mod1))[1, 2]
coef(summary(mod1))[2, 2]
tb0 <- b0/seb0
tb1 <- b1/seb1
c(tb0, tb1)
pvalues <- c(pt(tb0, 198, lower = FALSE)*2, pt(tb1, 198, lower = FALSE)*2)
pvalues
coef(summary(mod1))
TSS <- sum((y - mean(y))^2)
c(RSS, TSS)
R2 <- (TSS - RSS)/TSS
R2
# Or
summary(mod1)$r.squared
```


## Confidence Interval for $\beta_1$

$$\text{CI}_{1 - \alpha}(\beta_1) = \left[b_1 - t_{1- \alpha/2, n - p + 1}SE(b1), b_1 + t_{1- \alpha/2, n - p + 1}SE(b1) \right]$$

**Example:** Construct a 90% confidence interval for $\beta_1$.

```{r}
alpha <- 0.10
ct <- qt(1 - alpha/2, 198)
ct
b1 +c(-1, 1)*ct*seb1
# Or
confint(mod1, parm = "TV", level = 0.90)
confint(mod1)
```

### Linear Algebra

**Solution of linear systems** Find the solution(s) if any to the following linear equations.

$$2x + y - z = 8$$
$$-3x - y + 2z = -11$$
$$-2x + y + 2z = -3$$

```{r}
A <- matrix(c(2, -3, -2, 1, -1, 1, -1, 2, 2), nrow = 3)
b <- matrix(c(8, -11, -3), nrow = 3)
x <- solve(A)%*%b
x
# Or
solve(A, b)
```

See [wikipedia](https://en.wikipedia.org/wiki/Matrix_multiplication) for a review of matrix multiplication rules and properties.


Consider the 2 $\times$ 2 matrix $A$.

$$A = \begin{bmatrix}
2 & 4 \\
9 & 5 \\
\end{bmatrix}
$$

```{r}
A <- matrix(c(2, 9, 4, 5), nrow = 2)
A
t(A)          # Transpose of A
t(A)%*%A      # A'A
solve(A)%*%A  # I_2
zapsmall(solve(A)%*%A)  # What you expect I_2
```



```{r}
X <- model.matrix(mod1)
XTX <- t(X)%*%X
dim(XTX)
XTXI <- solve(XTX)
XTXI
# But it is best to compute this quantity using
summary(mod1)$cov.unscaled
betahat <- XTXI%*%t(X)%*%y
betahat
coef(mod1)
XTXI <- summary(mod1)$cov.unscaled
MSE <- summary(mod1)$sigma^2
var.cov.b <- MSE*XTXI
var.cov.b
```

## Multiple Linear Regression

```{r}
mod2 <- lm(Sales ~ TV + Radio, data = AD)
summary(mod2)
```

### Graphing the plane

```{r, echo = FALSE}
library(scatterplot3d)
s3d <- scatterplot3d(x = AD$TV, y = AD$Radio, 
              z = AD$Sales, xlab = "TV", 
              ylab = "Radio", zlab = "Sales",
              box = TRUE, pch = 20, color = "white",
              cex.symbols = 0.75, angle = 60, grid = FALSE)
s3d$plane3d(mod2 <- lm(Sales ~ TV + Radio, data = AD), 
            lty = "dotted", lty.box = "solid")
orig <- s3d$xyz.convert(x = AD$TV, y = AD$Radio, 
                        z = AD$Sales)
plane <- s3d$xyz.convert(x = AD$TV, y = AD$Radio,  fitted(mod2))
i.negpos <- 1 + (resid(mod2) > 0)
segments(orig$x, orig$y, plane$x, plane$y,
         col = c("darkblue", "lightblue3")[i.negpos])
s3d$points3d(x = AD$TV, y = AD$Radio, 
             z = AD$Sales,
             col = c("darkblue", "lightblue3")[i.negpos],
             pch = 20)
```





## Is There a Relationship Between the Response and Predictors?

```{r}
mod3 <- lm(Sales ~ TV + Radio + Newspaper, data = AD)
summary(mod3)
```

$$H_0: \beta_1 = \beta_2 = \beta_3 = 0$$
versus the alternative
$$H_1: \text{at least one } \beta_j \neq 0$$

The test statistic is $F = \frac{(\text{TSS} - \text{RSS})/p}{\text{RSS}/(n-p-1)}$

```{r}
anova(mod3)
SSR <- sum(anova(mod3)[1:3, 2])
MSR <- SSR/3
SSE <- anova(mod3)[4, 2]
MSE <- SSE/(200-3-1)
Fobs <- MSR/MSE
Fobs
pvalue <- pf(Fobs, 3, 196, lower = FALSE)
pvalue
# Or
summary(mod3)
summary(mod3)$fstatistic
```

Suppose we would like to test whether $\beta_2 = \beta_3 = 0$.  The reduced model with $\beta_2 = \beta_3 = 0$ is `mod1` while the full model is `mod3`.

```{r}
summary(mod3)
anova(mod1, mod3)
```

## Variable Selection

* Forward selection

```{r}
mod.fs <- lm(Sales ~ 1, data = AD)
SCOPE <- (~. + TV + Radio + Newspaper)
add1(mod.fs, scope = SCOPE, test = "F")
mod.fs <- update(mod.fs, .~. + TV)
add1(mod.fs, scope = SCOPE, test = "F")
mod.fs <- update(mod.fs, .~. + Radio)
add1(mod.fs, scope = SCOPE, test = "F")
summary(mod.fs)
```

* Using `stepAIC`

```{r}
stepAIC(lm(Sales ~ 1, data = AD), scope = .~TV + Radio + Newspaper, direction = "forward", test = "F")
```


* Backward elimination

```{r}
mod.be <- lm(Sales ~ TV + Radio + Newspaper, data = AD)
drop1(mod.be, test = "F")
mod.be <- update(mod.be, .~. - Newspaper)
drop1(mod.be, test = "F")
summary(mod.be)
```

* Using `stepAIC`

```{r}
stepAIC(lm(Sales ~ TV + Radio + Newspaper, data = AD), scope = .~TV + Radio + Newspaper, direction = "backward", test = "F")
```


## Diagnostic Plots

```{r}
residualPlots(mod2)
qqPlot(mod2)
influenceIndexPlot(mod2)
```



We use a _confidence interval_ to quantify the uncertainty surrounding the _average_ `Sales` over a large number of cities.  For example, given that $100,000 is spent on `TV` advertising and $20,000 is spent on `Radio` advertising in each city, the 95% confidence interval is [`r predict(mod.be, newdata = data.frame(TV = 100, Radio = 20), interval = "conf")[2]`, `r predict(mod.be, newdata = data.frame(TV = 100, Radio = 20), interval = "conf")[3]`].  We interpret this to mean that 95% of intervals of this form will contain the true value of `Sales`.

```{r}
predict(mod.be, newdata = data.frame(TV = 100, Radio = 20), interval = "conf")
```

On the other hand, a _prediction interval_ can be used to quantify the uncertainty surrounding `Sales` for a _particular_ city.  Given that $100,000 is spent on `TV` advertising and $20,000 is spent on `Radio` advertising in **a particular** city, the 95% prediction interval is [`r predict(mod.be, newdata = data.frame(TV = 100, Radio = 20), interval = "pred")[2]`, `r predict(mod.be, newdata = data.frame(TV = 100, Radio = 20), interval = "pred")[3]`].  We interpret this to mean that 95% of intervals of this form will contain the true value of `Sales` for this city.

```{r}
predict(mod.be, newdata = data.frame(TV = 100, Radio = 20), interval = "pred")
```

Note that both the intervals are centered at `r predict(mod.be, newdata = data.frame(TV = 100, Radio = 20))`, but that the prediction interval is substantially wider than the confidence interval, reflecting the increased uncertainty about `Sales` for a given city in comparison to the average `Sales` over many locations.


```{r}
Credit <- read.csv("http://www-bcf.usc.edu/~gareth/ISL/Credit.csv")
datatable(Credit[, -1], rownames = FALSE)
str(Credit)
```

